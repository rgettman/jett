package net.sf.jett.test.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import net.sf.jett.test.TestUtility;

/**
 * A <code>MockStatement</code> is a minimally implemented
 * <code>Statement</code> just to provide JDBC-like functionality without
 * a database.
 *
 * @author Randy Gettman
 * @since 0.6.0
 */
public class MockStatement implements Statement
{
   private MockConnection myConnection;

   /**
    * Constructs a <code>MockStatement</code> with a <code>MockConnection</code>.
    * @param connection A <code>MockStatement</code>.
    */
   public MockStatement(MockConnection connection)
   {
      myConnection = connection;
   }

   public ResultSet executeQuery(String sql) throws SQLException
   {
      return getResultSet();
   }
   public int executeUpdate(String sql) throws SQLException { return 0; }
   public void close() throws SQLException {}
   public int getMaxFieldSize() throws SQLException { return 4000; }
   public void setMaxFieldSize(int max) throws SQLException {}
   public int getMaxRows() throws SQLException { return 0; }
   public void setMaxRows(int max) throws SQLException {}
   public void setEscapeProcessing(boolean enable) throws SQLException {}
   public int getQueryTimeout() throws SQLException { return 0; }
   public void setQueryTimeout(int seconds) throws SQLException {}
   public void cancel() throws SQLException {}
   public SQLWarning getWarnings() throws SQLException { return null; }
   public void clearWarnings() throws SQLException {}
   public void setCursorName(String name) throws SQLException {}
   public boolean execute(String sql) throws SQLException
   {
      return true;
   }
   public ResultSet getResultSet() throws SQLException
   {
      return new MockResultSet(this, TestUtility.getEmployees());
   }
   public int getUpdateCount() throws SQLException { return -1; }
   public boolean getMoreResults() throws SQLException { return false; }
   public void setFetchDirection(int direction) throws SQLException {}
   public int getFetchDirection() throws SQLException { return ResultSet.FETCH_FORWARD; }
   public void setFetchSize(int rows) throws SQLException {}
   public int getFetchSize() throws SQLException { return 0; }
   public int getResultSetConcurrency() throws SQLException { return ResultSet.CONCUR_READ_ONLY; }
   public int getResultSetType() throws SQLException { return ResultSet.TYPE_FORWARD_ONLY; }
   public void addBatch(String sql) throws SQLException {}
   public void clearBatch() throws SQLException {}
   public int[] executeBatch() throws SQLException { return null; }
   public Connection getConnection() throws SQLException { return myConnection; }
   public boolean getMoreResults(int current) throws SQLException { return false;}
   public ResultSet getGeneratedKeys() throws SQLException { return null; }
   public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException { return 0; }
   public int executeUpdate(String sql, int[] columnIndexes) throws SQLException { return 0; }
   public int executeUpdate(String sql, String[] columnNames) throws SQLException { return 0; }
   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
   {
      return execute(sql);
   }
   public boolean execute(String sql, int[] columnIndexes) throws SQLException
   {
      return execute(sql);
   }
   public boolean execute(String sql, String[] columnNames) throws SQLException
   {
      return execute(sql);
   }
   public int getResultSetHoldability() throws SQLException { return ResultSet.HOLD_CURSORS_OVER_COMMIT; }
}
